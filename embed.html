<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Contribution Tree</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            overflow: hidden;
        }
        
        #treeCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        .tree-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            font-size: 14px;
            max-width: 250px;
        }
        
        .tree-info h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 16px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .stat-label {
            color: #666;
        }
        
        .stat-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .github-link {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 12px;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .github-link:hover {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .tree-info {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px 15px;
                font-size: 12px;
            }
            
            .github-link {
                bottom: 10px;
                right: 10px;
                padding: 6px 10px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <canvas id="treeCanvas"></canvas>
    
    <div class="tree-info" id="treeInfo" style="display: none;">
        <h3 id="treeTitle">ðŸŒ± Contribution Tree</h3>
        <div class="stat-row">
            <span class="stat-label">Contributions:</span>
            <span class="stat-value" id="contributions">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tree Level:</span>
            <span class="stat-value" id="treeLevel">Seed</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Lines of Code:</span>
            <span class="stat-value" id="linesOfCode">0</span>
        </div>
    </div>
    
    <div class="loading" id="loading">
        Growing your contribution tree...
    </div>
    
    <a href="#" class="github-link" id="githubLink" style="display: none;">
        View Full Interactive Tree
    </a>

    <script>
        class EmbedContributionTree {
            constructor() {
                this.canvas = document.getElementById('treeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.animationId = null;
                
                this.username = '';
                this.contributions = 0;
                this.linesOfCode = 0;
                this.treeLevel = 'Seed';
                
                this.branches = [];
                this.leaves = [];
                
                this.init();
                this.loadFromURL();
            }
            
            init() {
                // Set canvas size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Draw initial seed
                this.drawSeed();
                
                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            drawGround() {
                const groundY = this.canvas.height - 60;
                
                // Ground
                this.ctx.fillStyle = '#8B7355';
                this.ctx.fillRect(0, groundY, this.canvas.width, 60);
                
                // Grass
                this.ctx.strokeStyle = '#4CAF50';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < this.canvas.width; i += 8) {
                    const grassHeight = Math.random() * 12 + 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, groundY);
                    this.ctx.lineTo(i, groundY - grassHeight);
                    this.ctx.stroke();
                }
            }
            
            drawSeed() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGround();
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height - 60;
                
                // Draw seed
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.ellipse(centerX, centerY - 15, 12, 18, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            async loadFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const username = urlParams.get('user') || urlParams.get('username');
                
                if (!username) {
                    this.showError('No username provided');
                    return;
                }
                
                this.username = username;
                
                try {
                    await this.fetchGitHubData(username);
                    this.hideLoading();
                    this.showTreeInfo();
                    this.growTree();
                } catch (error) {
                    console.error('Error:', error);
                    // Use demo data
                    this.contributions = Math.floor(Math.random() * 800) + 100;
                    this.linesOfCode = this.contributions * 50;
                    this.updateTreeLevel();
                    this.hideLoading();
                    this.showTreeInfo();
                    this.growTree();
                }
            }
            
            async fetchGitHubData(username) {
                try {
                    console.log(`Fetching real GitHub data for ${username}...`);
                    
                    // Fetch user data and repositories from real GitHub API
                    const [userData, reposData] = await Promise.all([
                        this.fetchGitHubUser(username),
                        this.fetchGitHubRepos(username)
                    ]);
                    
                    // Calculate real contribution statistics
                    const stats = this.calculateContributionStats(userData, reposData);
                    
                    this.contributions = stats.contributions;
                    this.linesOfCode = stats.linesOfCode;
                    this.updateTreeLevel();
                    
                    console.log('Real GitHub data loaded:', stats);
                    
                } catch (error) {
                    console.error('Error fetching GitHub data:', error.message);
                    // Fallback values if API fails
                    this.contributions = 150;
                    this.linesOfCode = 7500;
                    this.updateTreeLevel();
                }
            }
            
            async fetchGitHubUser(username) {
                const response = await fetch(`https://api.github.com/users/${username}`, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'GitHub-Tree-Embed'
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`User "${username}" not found`);
                    } else if (response.status === 403) {
                        throw new Error('GitHub API rate limit exceeded');
                    } else {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                }
                
                return await response.json();
            }
            
            async fetchGitHubRepos(username) {
                try {
                    let allRepos = [];
                    let page = 1;
                    let hasMore = true;
                    
                    // Fetch up to 3 pages for embed version to be faster
                    while (hasMore && page <= 3) {
                        const response = await fetch(
                            `https://api.github.com/users/${username}/repos?per_page=100&page=${page}&sort=updated&direction=desc`,
                            {
                                headers: {
                                    'Accept': 'application/vnd.github.v3+json',
                                    'User-Agent': 'GitHub-Tree-Embed'
                                }
                            }
                        );
                        
                        if (!response.ok) {
                            console.warn(`Error fetching repos page ${page}:`, response.status);
                            break;
                        }
                        
                        const repos = await response.json();
                        allRepos = allRepos.concat(repos);
                        hasMore = repos.length === 100;
                        page++;
                        
                        // Small delay for API respect
                        if (hasMore) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    return allRepos;
                    
                } catch (error) {
                    console.warn('Error fetching repositories:', error.message);
                    return [];
                }
            }
            
            calculateContributionStats(userData, reposData) {
                const accountCreated = new Date(userData.created_at);
                const accountAgeYears = (new Date() - accountCreated) / (1000 * 60 * 60 * 24 * 365);
                
                // Filter out forked repositories
                const originalRepos = reposData.filter(repo => !repo.fork);
                
                let totalContributions = 0;
                let estimatedLinesOfCode = 0;
                
                // Base contributions from account metrics
                totalContributions += userData.public_repos * 8;
                totalContributions += Math.min(userData.followers * 3, 300);
                
                // Process repositories
                originalRepos.forEach(repo => {
                    const repoSize = repo.size || 0;
                    const stars = repo.stargazers_count || 0;
                    const forks = repo.forks_count || 0;
                    
                    // Lines of code estimation
                    estimatedLinesOfCode += repoSize * 25;
                    
                    // Contribution calculation
                    let repoContribution = Math.min(repoSize * 0.08, 40);
                    repoContribution += Math.min(stars * 4, 120);
                    repoContribution += Math.min(forks * 6, 60);
                    
                    // Recent activity bonus
                    const lastUpdate = new Date(repo.updated_at);
                    const daysSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60 * 24);
                    
                    if (daysSinceUpdate < 30) repoContribution *= 1.4;
                    else if (daysSinceUpdate < 90) repoContribution *= 1.1;
                    
                    totalContributions += repoContribution;
                });
                
                // Account age factor
                const ageMultiplier = Math.min(1 + (accountAgeYears * 0.4), 2.5);
                totalContributions *= ageMultiplier;
                
                // Ensure minimum values for active accounts
                if (originalRepos.length > 0) {
                    totalContributions = Math.max(totalContributions, 75);
                    estimatedLinesOfCode = Math.max(estimatedLinesOfCode, 1500);
                }
                
                return {
                    contributions: Math.floor(totalContributions),
                    linesOfCode: Math.floor(estimatedLinesOfCode)
                };
            }
            
            updateTreeLevel() {
                if (this.contributions <= 50) {
                    this.treeLevel = 'Sprout';
                } else if (this.contributions <= 200) {
                    this.treeLevel = 'Sapling';
                } else if (this.contributions <= 500) {
                    this.treeLevel = 'Mature Tree';
                } else {
                    this.treeLevel = 'Ancient Tree';
                }
            }
            
            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }
            
            showTreeInfo() {
                document.getElementById('treeTitle').textContent = `ðŸŒ± ${this.username}'s Tree`;
                document.getElementById('contributions').textContent = this.contributions;
                document.getElementById('treeLevel').textContent = this.treeLevel;
                document.getElementById('linesOfCode').textContent = this.linesOfCode.toLocaleString();
                document.getElementById('treeInfo').style.display = 'block';
                
                // Update GitHub link
                const githubLink = document.getElementById('githubLink');
                const baseUrl = window.location.origin + window.location.pathname.replace('embed.html', 'index.html');
                githubLink.href = `${baseUrl}?user=${this.username}`;
                githubLink.style.display = 'block';
            }
            
            showError(message) {
                document.getElementById('loading').textContent = `Error: ${message}`;
            }
            
            growTree() {
                this.generate2DTree();
                this.animate2DGrowth();
            }
            
            generate2DTree() {
                this.branches = [];
                this.leaves = [];
                
                const centerX = this.canvas.width / 2;
                const groundY = this.canvas.height - 60;
                const trunkHeight = Math.min(200, 80 + (this.contributions * 0.15));
                const maxBranches = Math.min(15, Math.floor(this.contributions / 30) + 2);
                
                // Main trunk
                this.branches.push({
                    startX: centerX,
                    startY: groundY,
                    endX: centerX,
                    endY: groundY - trunkHeight,
                    thickness: Math.max(12, this.contributions / 60),
                    level: 0,
                    grown: false
                });
                
                this.generateBranches(centerX, groundY - trunkHeight, trunkHeight * 0.6, 0, maxBranches);
                this.generateLeaves();
            }
            
            generateBranches(x, y, remainingHeight, level, maxBranches) {
                if (level >= 3 || remainingHeight < 30 || this.branches.length >= maxBranches) {
                    return;
                }
                
                const numBranches = Math.min(2, Math.max(1, Math.floor(this.contributions / 100) + 1));
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (Math.PI / 4) * (i - numBranches / 2) + (Math.random() - 0.5) * 0.4;
                    const length = remainingHeight * (0.6 + Math.random() * 0.3);
                    const thickness = Math.max(2, 12 - level * 3);
                    
                    const endX = x + Math.sin(angle) * length;
                    const endY = y - Math.cos(angle) * length;
                    
                    this.branches.push({
                        startX: x,
                        startY: y,
                        endX: endX,
                        endY: endY,
                        thickness: thickness,
                        level: level + 1,
                        grown: false
                    });
                    
                    // Recursively generate more branches
                    if (Math.random() > 0.4) {
                        this.generateBranches(endX, endY, length * 0.7, level + 1, maxBranches);
                    }
                }
            }
            
            generateLeaves() {
                const leafCount = Math.min(80, this.contributions / 6);
                
                for (let i = 0; i < leafCount; i++) {
                    // Find a random branch to attach leaf to
                    const branch = this.branches[Math.floor(Math.random() * this.branches.length)];
                    if (branch && branch.level >= 1) {
                        const t = Math.random();
                        const leafX = branch.startX + (branch.endX - branch.startX) * t;
                        const leafY = branch.startY + (branch.endY - branch.startY) * t;
                        
                        this.leaves.push({
                            x: leafX + (Math.random() - 0.5) * 30,
                            y: leafY + (Math.random() - 0.5) * 30,
                            size: Math.random() * 5 + 4,
                            color: this.getLeafColor(),
                            rotation: Math.random() * Math.PI * 2,
                            grown: false,
                            opacity: 0
                        });
                    }
                }
            }
            
            getLeafColor() {
                const colors = ['#4CAF50', '#8BC34A', '#CDDC39', '#FFC107'];
                const season = Math.floor(this.contributions / 150) % colors.length;
                return colors[season];
            }
            
            animate2DGrowth() {
                let branchIndex = 0;
                let leafIndex = 0;
                let startTime = Date.now();
                
                const animate = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw background
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#98FB98');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.drawGround();
                    
                    const elapsed = Date.now() - startTime;
                    const branchGrowthDuration = 2000;
                    const leafGrowthStart = 1500;
                    
                    // Grow branches
                    if (branchIndex < this.branches.length) {
                        const branchesPerFrame = Math.max(1, Math.floor(this.branches.length / (branchGrowthDuration / 16)));
                        for (let i = 0; i < branchesPerFrame && branchIndex < this.branches.length; i++) {
                            this.branches[branchIndex].grown = true;
                            branchIndex++;
                        }
                    }
                    
                    // Draw grown branches
                    this.branches.forEach(branch => {
                        if (branch.grown) {
                            this.drawBranch(branch);
                        }
                    });
                    
                    // Grow leaves
                    if (elapsed > leafGrowthStart && leafIndex < this.leaves.length) {
                        const leavesPerFrame = Math.max(1, Math.floor(this.leaves.length / 20));
                        for (let i = 0; i < leavesPerFrame && leafIndex < this.leaves.length; i++) {
                            this.leaves[leafIndex].grown = true;
                            this.leaves[leafIndex].opacity = 1;
                            leafIndex++;
                        }
                    }
                    
                    // Draw grown leaves
                    this.leaves.forEach(leaf => {
                        if (leaf.grown) {
                            this.drawLeaf(leaf);
                        }
                    });
                    
                    if (branchIndex < this.branches.length || leafIndex < this.leaves.length || elapsed < 2500) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            drawBranch(branch) {
                this.ctx.strokeStyle = `hsl(${30 - branch.level * 5}, 50%, ${30 + branch.level * 5}%)`;
                this.ctx.lineWidth = branch.thickness;
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(branch.startX, branch.startY);
                this.ctx.lineTo(branch.endX, branch.endY);
                this.ctx.stroke();
            }
            
            drawLeaf(leaf) {
                this.ctx.save();
                this.ctx.globalAlpha = leaf.opacity;
                this.ctx.translate(leaf.x, leaf.y);
                this.ctx.rotate(leaf.rotation);
                
                // Draw realistic leaf shape
                this.ctx.fillStyle = leaf.color;
                this.ctx.beginPath();
                
                // Leaf shape using curves - looks like a real leaf
                const size = leaf.size;
                this.ctx.moveTo(0, -size);
                this.ctx.quadraticCurveTo(size * 0.6, -size * 0.3, size * 0.3, 0);
                this.ctx.quadraticCurveTo(size * 0.6, size * 0.3, 0, size);
                this.ctx.quadraticCurveTo(-size * 0.6, size * 0.3, -size * 0.3, 0);
                this.ctx.quadraticCurveTo(-size * 0.6, -size * 0.3, 0, -size);
                this.ctx.fill();
                
                // Add leaf vein
                this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -size);
                this.ctx.lineTo(0, size);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            easeOutBounce(t) {
                const n1 = 7.5625;
                const d1 = 2.75;
                
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            }
            
            onWindowResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Redraw current state
                if (this.contributions === 0) {
                    this.drawSeed();
                } else {
                    // Redraw the current tree state
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Background
                    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#98FB98');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.drawGround();
                    
                    // Redraw branches and leaves
                    this.branches.forEach(branch => {
                        if (branch.grown) {
                            this.drawBranch(branch);
                        }
                    });
                    
                    this.leaves.forEach(leaf => {
                        if (leaf.grown) {
                            this.drawLeaf(leaf);
                        }
                    });
                }
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            new EmbedContributionTree();
        });
    </script>
</body>
</html>
