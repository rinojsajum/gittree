<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Tree Image Generator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f6f8fa;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            color: #24292e;
            margin-bottom: 20px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        input, button {
            padding: 10px 15px;
            margin: 5px;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            background: #2da44e;
            color: white;
            border: none;
            cursor: pointer;
        }
        
        button:hover {
            background: #2c974b;
        }
        
        button:disabled {
            background: #94d3a2;
            cursor: not-allowed;
        }
        
        #treeCanvas {
            width: 600px;
            height: 400px;
            margin: 20px auto;
            border: 1px solid #d0d7de;
            border-radius: 8px;
            display: block;
            background: white;
        }
        
        .download-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        
        .code-block {
            background: #f6f8fa;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-family: 'SFMono-Regular', Consolas, monospace;
            font-size: 13px;
            overflow-x: auto;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: #f6f8fa;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .loading {
            color: #656d76;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ± GitHub Tree Image Generator</h1>
        
        <div class="controls">
            <h3>Generate Your 3D Tree Image</h3>
            <input type="text" id="username" placeholder="Enter GitHub username" />
            <button id="generateTree">Generate Tree</button>
            <button id="downloadImage" disabled>Download Image</button>
            
            <div class="stats" id="stats" style="display: none;">
                <div class="stat-item">
                    <strong>Contributions:</strong> <span id="contributions">0</span>
                </div>
                <div class="stat-item">
                    <strong>Tree Level:</strong> <span id="treeLevel">Seed</span>
                </div>
            </div>
        </div>
        
        <canvas id="treeCanvas" width="600" height="400"></canvas>
        
        <div class="download-section" id="downloadSection" style="display: none;">
            <h3>ðŸ“‹ Use in Your GitHub README</h3>
            <p>After downloading your tree image, upload it to your repository and use this markdown:</p>
            <div class="code-block" id="markdownCode">
                <div>Upload your downloaded tree image to your repo, then use:</div>
                <br>
                <div>&lt;div align="center"&gt;</div>
                <div>&nbsp;&nbsp;&lt;img src="./your-tree-image.png" alt="My GitHub Contribution Tree" width="600"/&gt;</div>
                <div>&lt;/div&gt;</div>
            </div>
            
            <h4>Alternative: Host the image and use direct link</h4>
            <div class="code-block">
                <div>&lt;div align="center"&gt;</div>
                <div>&nbsp;&nbsp;&lt;img src="https://your-domain.com/path/to/tree-image.png" alt="My GitHub Contribution Tree" width="600"/&gt;</div>
                <div>&lt;/div&gt;</div>
            </div>
            
            <p><strong>ðŸ’¡ Pro Tip:</strong> You can regenerate and update your tree image periodically to show your latest contributions!</p>
        </div>
    </div>

    <script>
        class TreeImageGenerator {
            constructor() {
                this.canvas = document.getElementById('treeCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.contributions = 0;
                this.treeLevel = 'Seed';
                this.username = '';
                this.branches = [];
                this.leaves = [];
                
                this.init();
                this.setupEventListeners();
            }
            
            init() {
                // Initial render
                this.drawSeed();
            }
            
            drawGround() {
                const groundY = this.canvas.height - 50;
                
                // Ground
                this.ctx.fillStyle = '#7CB342';
                this.ctx.fillRect(0, groundY, this.canvas.width, 50);
                
                // Grass
                this.ctx.strokeStyle = '#4CAF50';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < this.canvas.width; i += 6) {
                    const grassHeight = Math.random() * 10 + 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, groundY);
                    this.ctx.lineTo(i, groundY - grassHeight);
                    this.ctx.stroke();
                }
            }
            
            drawSeed() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGround();
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height - 50;
                
                // Draw seed
                this.ctx.fillStyle = '#8B4513';
                this.ctx.beginPath();
                this.ctx.ellipse(centerX, centerY - 15, 10, 15, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            setupEventListeners() {
                document.getElementById('generateTree').addEventListener('click', () => this.generateTree());
                document.getElementById('downloadImage').addEventListener('click', () => this.downloadImage());
                
                document.getElementById('username').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.generateTree();
                    }
                });
            }
            
            async generateTree() {
                const username = document.getElementById('username').value.trim();
                if (!username) {
                    alert('Please enter a GitHub username');
                    return;
                }
                
                this.username = username;
                const button = document.getElementById('generateTree');
                const originalText = button.textContent;
                button.textContent = 'Generating...';
                button.disabled = true;
                
                try {
                    // Simulate GitHub API call
                    await this.fetchContributionData(username);
                    
                                    // Generate new tree
                this.create2DTree();
                    this.updateStats();
                    
                    // Enable download
                    document.getElementById('downloadImage').disabled = false;
                    document.getElementById('downloadSection').style.display = 'block';
                    
                } catch (error) {
                    alert('Error generating tree: ' + error.message);
                } finally {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            }
            
            async fetchContributionData(username) {
                try {
                    console.log(`Fetching real GitHub data for ${username}...`);
                    
                    // Fetch real GitHub data
                    const [userData, reposData] = await Promise.all([
                        this.fetchGitHubUser(username),
                        this.fetchGitHubRepos(username)
                    ]);
                    
                    // Calculate real contribution statistics
                    const stats = this.calculateContributionStats(userData, reposData);
                    
                    this.contributions = stats.contributions;
                    this.updateTreeLevel();
                    
                    console.log('Real contribution data loaded:', stats);
                    
                } catch (error) {
                    console.error('Error fetching GitHub data:', error.message);
                    // Fallback values if API fails
                    this.contributions = 200;
                    this.updateTreeLevel();
                    alert(`Warning: ${error.message}. Using fallback values.`);
                }
            }
            
            async fetchGitHubUser(username) {
                const response = await fetch(`https://api.github.com/users/${username}`, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'GitHub-Tree-Generator'
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`User "${username}" not found`);
                    } else if (response.status === 403) {
                        throw new Error('GitHub API rate limit exceeded. Please try again later.');
                    } else {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                }
                
                return await response.json();
            }
            
            async fetchGitHubRepos(username) {
                try {
                    let allRepos = [];
                    let page = 1;
                    let hasMore = true;
                    
                    // Fetch up to 4 pages for image generation
                    while (hasMore && page <= 4) {
                        const response = await fetch(
                            `https://api.github.com/users/${username}/repos?per_page=100&page=${page}&sort=updated&direction=desc`,
                            {
                                headers: {
                                    'Accept': 'application/vnd.github.v3+json',
                                    'User-Agent': 'GitHub-Tree-Generator'
                                }
                            }
                        );
                        
                        if (!response.ok) {
                            console.warn(`Error fetching repos page ${page}:`, response.status);
                            break;
                        }
                        
                        const repos = await response.json();
                        allRepos = allRepos.concat(repos);
                        hasMore = repos.length === 100;
                        page++;
                        
                        // Small delay for API respect
                        if (hasMore) {
                            await new Promise(resolve => setTimeout(resolve, 150));
                        }
                    }
                    
                    return allRepos;
                    
                } catch (error) {
                    console.warn('Error fetching repositories:', error.message);
                    return [];
                }
            }
            
            calculateContributionStats(userData, reposData) {
                const accountCreated = new Date(userData.created_at);
                const accountAgeYears = (new Date() - accountCreated) / (1000 * 60 * 60 * 24 * 365);
                
                // Filter out forked repositories
                const originalRepos = reposData.filter(repo => !repo.fork);
                
                let totalContributions = 0;
                
                // Base contributions from account metrics
                totalContributions += userData.public_repos * 10;
                totalContributions += Math.min(userData.followers * 4, 400);
                
                // Process repositories
                originalRepos.forEach(repo => {
                    const repoSize = repo.size || 0;
                    const stars = repo.stargazers_count || 0;
                    const forks = repo.forks_count || 0;
                    
                    // Contribution calculation with higher weight for popular repos
                    let repoContribution = Math.min(repoSize * 0.1, 50);
                    repoContribution += Math.min(stars * 5, 150);
                    repoContribution += Math.min(forks * 8, 80);
                    
                    // Recent activity bonus
                    const lastUpdate = new Date(repo.updated_at);
                    const daysSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60 * 24);
                    
                    if (daysSinceUpdate < 30) repoContribution *= 1.6;
                    else if (daysSinceUpdate < 90) repoContribution *= 1.3;
                    
                    totalContributions += repoContribution;
                });
                
                // Account age factor
                const ageMultiplier = Math.min(1 + (accountAgeYears * 0.5), 3);
                totalContributions *= ageMultiplier;
                
                // Ensure minimum values for active accounts
                if (originalRepos.length > 0) {
                    totalContributions = Math.max(totalContributions, 100);
                }
                
                return {
                    contributions: Math.floor(totalContributions)
                };
            }
            
            updateTreeLevel() {
                if (this.contributions <= 50) {
                    this.treeLevel = 'Sprout';
                } else if (this.contributions <= 200) {
                    this.treeLevel = 'Sapling';
                } else if (this.contributions <= 500) {
                    this.treeLevel = 'Mature Tree';
                } else {
                    this.treeLevel = 'Ancient Tree';
                }
            }
            
            updateStats() {
                document.getElementById('contributions').textContent = this.contributions;
                document.getElementById('treeLevel').textContent = this.treeLevel;
                document.getElementById('stats').style.display = 'flex';
            }
            
            drawSeed() {
                const seedGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                const seedMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const seed = new THREE.Mesh(seedGeometry, seedMaterial);
                seed.position.y = 0.15;
                seed.castShadow = true;
                this.treeGroup.add(seed);
            }
            
            create2DTree() {
                this.branches = [];
                this.leaves = [];
                
                const centerX = this.canvas.width / 2;
                const groundY = this.canvas.height - 50;
                const trunkHeight = Math.min(250, 80 + (this.contributions * 0.2));
                const maxBranches = Math.min(18, Math.floor(this.contributions / 25) + 3);
                
                // Main trunk
                this.branches.push({
                    startX: centerX,
                    startY: groundY,
                    endX: centerX,
                    endY: groundY - trunkHeight,
                    thickness: Math.max(15, this.contributions / 40),
                    level: 0
                });
                
                this.generateBranches(centerX, groundY - trunkHeight, trunkHeight * 0.6, 0, maxBranches);
                this.generateLeaves();
                
                // Draw the complete tree
                this.drawCompleteTree();
            }
            
            createTrunk(height, radius) {
                const trunkGeometry = new THREE.CylinderGeometry(radius, radius * 1.4, height, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = height / 2;
                trunk.castShadow = true;
                
                this.treeGroup.add(trunk);
            }
            
            createBranches(trunkHeight, trunkRadius) {
                const numBranches = Math.min(18, Math.floor(this.contributions / 25) + 3);
                
                for (let i = 0; i < numBranches; i++) {
                    const branchLevel = Math.floor(i / 4);
                    const branchHeight = trunkHeight * (0.6 + branchLevel * 0.15);
                    const branchLength = trunkHeight * (0.4 + branchLevel * 0.1);
                    const branchRadius = trunkRadius * (0.5 - branchLevel * 0.1);
                    
                    const angle = (i * Math.PI * 2) / (numBranches / (branchLevel + 1));
                    const tilt = Math.PI / 6 + (branchLevel * Math.PI / 12);
                    
                    const branchGeometry = new THREE.CylinderGeometry(
                        branchRadius * 0.3,
                        branchRadius,
                        branchLength,
                        6
                    );
                    const branchMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.08, 0.7, 0.25 + branchLevel * 0.05)
                    });
                    
                    const branch = new THREE.Mesh(branchGeometry, branchMaterial);
                    
                    branch.position.y = branchHeight;
                    branch.position.x = Math.cos(angle) * (trunkRadius + branchLength / 3);
                    branch.position.z = Math.sin(angle) * (trunkRadius + branchLength / 3);
                    
                    branch.rotation.z = Math.cos(angle) * tilt;
                    branch.rotation.x = Math.sin(angle) * tilt;
                    
                    branch.castShadow = true;
                    this.treeGroup.add(branch);
                }
            }
            
            createLeaves() {
                const leafCount = Math.min(120, this.contributions / 5);
                
                for (let i = 0; i < leafCount; i++) {
                    const leafGeometry = new THREE.SphereGeometry(0.12, 6, 4);
                    const leafColor = this.getLeafColor();
                    const leafMaterial = new THREE.MeshLambertMaterial({ color: leafColor });
                    
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    
                    const radius = 1.5 + Math.random() * 3.5;
                    const height = 2.5 + Math.random() * 5;
                    const angle = Math.random() * Math.PI * 2;
                    
                    leaf.position.x = Math.cos(angle) * radius;
                    leaf.position.z = Math.sin(angle) * radius;
                    leaf.position.y = height;
                    
                    leaf.scale.setScalar(0.6 + Math.random() * 0.8);
                    leaf.castShadow = true;
                    
                    this.treeGroup.add(leaf);
                }
            }
            
            getLeafColor() {
                const colors = [0x4CAF50, 0x8BC34A, 0xCDDC39, 0xFFC107, 0xFF9800];
                const season = Math.floor(this.contributions / 150) % colors.length;
                return colors[season];
            }
            
            addUsernameLabel() {
                // Create a simple text representation using geometry
                // (In a real implementation, you might want to use a texture with text)
                const labelGeometry = new THREE.PlaneGeometry(3, 0.5);
                const labelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x333333,
                    transparent: true,
                    opacity: 0.8
                });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(0, -0.5, 0);
                label.rotation.x = -Math.PI / 2;
                this.treeGroup.add(label);
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            
            generateBranches(x, y, remainingHeight, level, maxBranches) {
                if (level >= 4 || remainingHeight < 25 || this.branches.length >= maxBranches) {
                    return;
                }
                
                const numBranches = Math.min(3, Math.max(1, Math.floor(this.contributions / 80) + 1));
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (Math.PI / 5) * (i - numBranches / 2) + (Math.random() - 0.5) * 0.4;
                    const length = remainingHeight * (0.6 + Math.random() * 0.3);
                    const thickness = Math.max(2, 15 - level * 4);
                    
                    const endX = x + Math.sin(angle) * length;
                    const endY = y - Math.cos(angle) * length;
                    
                    this.branches.push({
                        startX: x,
                        startY: y,
                        endX: endX,
                        endY: endY,
                        thickness: thickness,
                        level: level + 1
                    });
                    
                    // Recursively generate more branches
                    if (Math.random() > 0.3) {
                        this.generateBranches(endX, endY, length * 0.7, level + 1, maxBranches);
                    }
                }
            }
            
            generateLeaves() {
                const leafCount = Math.min(120, this.contributions / 5);
                
                for (let i = 0; i < leafCount; i++) {
                    // Find a random branch to attach leaf to
                    const branch = this.branches[Math.floor(Math.random() * this.branches.length)];
                    if (branch && branch.level >= 1) {
                        const t = Math.random();
                        const leafX = branch.startX + (branch.endX - branch.startX) * t;
                        const leafY = branch.startY + (branch.endY - branch.startY) * t;
                        
                        this.leaves.push({
                            x: leafX + (Math.random() - 0.5) * 25,
                            y: leafY + (Math.random() - 0.5) * 25,
                            size: Math.random() * 5 + 4,
                            color: this.getLeafColor(),
                            rotation: Math.random() * Math.PI * 2
                        });
                    }
                }
            }
            
            getLeafColor() {
                const colors = ['#4CAF50', '#8BC34A', '#CDDC39', '#FFC107', '#FF9800'];
                const season = Math.floor(this.contributions / 150) % colors.length;
                return colors[season];
            }
            
            drawCompleteTree() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGround();
                
                // Draw all branches
                this.branches.forEach(branch => {
                    this.drawBranch(branch);
                });
                
                // Draw all leaves
                this.leaves.forEach(leaf => {
                    this.drawLeaf(leaf);
                });
                
                // Add username label
                this.drawUsernameLabel();
            }
            
            drawBranch(branch) {
                this.ctx.strokeStyle = `hsl(${30 - branch.level * 5}, 60%, ${25 + branch.level * 5}%)`;
                this.ctx.lineWidth = branch.thickness;
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(branch.startX, branch.startY);
                this.ctx.lineTo(branch.endX, branch.endY);
                this.ctx.stroke();
            }
            
            drawLeaf(leaf) {
                this.ctx.save();
                this.ctx.translate(leaf.x, leaf.y);
                this.ctx.rotate(leaf.rotation);
                
                // Draw realistic leaf shape
                this.ctx.fillStyle = leaf.color;
                this.ctx.beginPath();
                
                // Leaf shape using curves - looks like a real leaf
                const size = leaf.size;
                this.ctx.moveTo(0, -size);
                this.ctx.quadraticCurveTo(size * 0.6, -size * 0.3, size * 0.3, 0);
                this.ctx.quadraticCurveTo(size * 0.6, size * 0.3, 0, size);
                this.ctx.quadraticCurveTo(-size * 0.6, size * 0.3, -size * 0.3, 0);
                this.ctx.quadraticCurveTo(-size * 0.6, -size * 0.3, 0, -size);
                this.ctx.fill();
                
                // Add leaf vein
                this.ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -size);
                this.ctx.lineTo(0, size);
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            drawUsernameLabel() {
                this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
                this.ctx.fillRect(10, 10, 200, 40);
                this.ctx.strokeStyle = '#ddd';
                this.ctx.strokeRect(10, 10, 200, 40);
                
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillText(`${this.username}'s GitHub Tree`, 20, 30);
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#666';
                this.ctx.fillText(`${this.contributions} contributions`, 20, 45);
            }
            
            downloadImage() {
                // Create download link
                this.canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `${this.username}-github-tree.png`;
                    link.href = url;
                    link.click();
                    
                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                }, 'image/png', 1.0);
                
                alert('Tree image downloaded! Upload it to your repository and use the markdown code below.');
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TreeImageGenerator();
        });
    </script>
</body>
</html>
